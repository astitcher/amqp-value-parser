%name PnParser

%token_prefix PN_TOK_

%include {
#include <proton/codec.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "amqp-performatives.c"

typedef struct {
  bool initial_array_value;
} parse_context;

static inline void check_initial_array_value(pn_data_t* data, parse_context* context, pn_type_t type) {
  if (!context->initial_array_value) return;

  pn_data_put_array(data, false, type);
  pn_data_enter(data);
  context->initial_array_value = false;
}

}

%extra_context { parse_context* context }
%extra_argument { pn_data_t* data }

%start_symbol start

%token_type  { pn_bytes_t }

%type binary { pn_bytes_t }
%type string { pn_bytes_t }
%type symbol { pn_bytes_t }
%type id     { pn_bytes_t }
%type label  { pn_bytes_t }
%type int    { int64_t }
%type uint   { uint64_t }
%type float  { double }
%type descriptor_value { uint64_t }
%type descriptor { uint64_t }

%type value        { pn_type_t }
%type simple_value { pn_type_t }
%type array_value  { pn_type_t }
%type array_list   { pn_type_t }

%syntax_error {
    pn_data_clear(data);
    pn_error_format(pn_data_error(data), PN_ERR,
        "Syntax error near \"%.*s\"\n", (int)TOKEN.size, TOKEN.start);
}

start ::= value .

/* Error recovery strategy is ignore the rest of the input! */
start ::= error .

binary(O) ::= BINARY(S) . { O = S; }
string(O) ::= STRING(S) . { O = S; }
id(O)     ::= ID(S) .     { O = S; }
/* No need to fiddle with strings as the conversion will halt on the first non-numeric character anyway */
int(O)    ::= INT(S) .    { O = strtoll(S.start, 0, 10); }
uint(O)   ::= BINT(S) .   { O = strtoull(S.start, 0, 2); }
uint(O)   ::= OINT(S) .   { O = strtoull(S.start, 0, 8); }
uint(O)   ::= HINT(S) .   { O = strtoull(S.start, 0, 16); }
float(O)  ::= FLOAT(S) .  { O = strtod(S.start, 0); }

value ::= described_value .
value ::= map .
value ::= list .
value ::= array .
value ::= simple_value .

array_value(T) ::= map .               { T = PN_MAP; }
array_value(T) ::= list .              { T = PN_LIST; }
array_value(TO) ::= simple_value(TI) . { TO = TI; }

// Check whether an unadorned id is "true", "false", "null" otherwise treat as a symbol
simple_value(T) ::= id(S) .      { if (strncmp("true", S.start, S.size)==0){
                                     T = PN_BOOL;
                                     check_initial_array_value(data, context, T);
                                     pn_data_put_bool(data, true);
                                   } else if (strncmp("false", S.start, S.size)==0) {
                                     T = PN_BOOL;
                                     check_initial_array_value(data, context, T);
                                     pn_data_put_bool(data, false);
                                   } else if (strncmp("null", S.start, S.size)==0) {
                                     T = PN_NULL;
                                     check_initial_array_value(data, context, T);
                                     pn_data_put_null(data);
                                   } else {
                                     T = PN_SYMBOL;
                                     check_initial_array_value(data, context, T);
                                     pn_data_put_symbol(data, S);
                                   }
                                 }
simple_value(T) ::= int(I) .     { T = PN_LONG; check_initial_array_value(data, context, T); pn_data_put_long(data, I); }
simple_value(T) ::= uint(I) .    { T = PN_ULONG; check_initial_array_value(data, context, T); pn_data_put_ulong(data, I); }
simple_value(T) ::= binary(S) .  { T = PN_BINARY; check_initial_array_value(data, context, T); pn_data_put_binary(data, S); }
simple_value(T) ::= string(S) .  { T = PN_STRING; check_initial_array_value(data, context, T); pn_data_put_string(data, S); }
simple_value(T) ::= float(F) .   { T = PN_DOUBLE; check_initial_array_value(data, context, T); pn_data_put_double(data, F); }
simple_value(T) ::= symbol(S) .  { T = PN_SYMBOL; check_initial_array_value(data, context, T); pn_data_put_symbol(data, S);}

label(O) ::= id(I) .                     { O = I; }

descriptor_value(O) ::= label(I) .       { uint64_t d = pni_lookup_performative_value(I.start, I.size);
                                           if (d) {
                                            pn_data_put_ulong(data, d);
                                           } else {
                                            pn_data_put_symbol(data, I);
                                           }
                                           O = d; }
descriptor_value(O) ::= symbol .         { O = 0; }
descriptor_value(O) ::= int(I) .         { pn_data_put_ulong(data, I); O = I; }
descriptor_value(O) ::= uint(I) .        { pn_data_put_ulong(data, I); O = I; }

described_value_value ::= map .
described_value_value ::= list .
described_value_value ::= simple_value .

descriptor ::= descriptor_value .
descriptor ::= label(L) LPAREN descriptor_value(V) RPAREN .
                                         { int d = pni_lookup_performative_value(L.start, L.size);
                                           if ( d && d!=V ) {
                                             pn_error_format(pn_data_error(data), PN_ERR,
                                               "Descriptor %.*s(%d) does not match value %d",
                                               L.size, L.start, d, V);
                                           }
                                         }

described_value_head ::= AT .            { pn_data_put_described(data); pn_data_enter(data); }
described_value ::= described_value_head descriptor described_value_value . { pn_data_exit(data); }

map_key ::= simple_value .

map_entry ::= map_key EQUAL value .
map_entry ::= map_key DARROW value .
map_entry ::= map_key COLON value .

map_list ::= map_entry .
map_list ::= map_list COMMA map_entry .

map_head ::= LBRACE .                    { check_initial_array_value(data, context, PN_MAP); pn_data_put_map(data); pn_data_enter(data); }
map ::= map_head RBRACE .                { pn_data_exit(data); }
map ::= map_head map_list RBRACE .       { pn_data_exit(data); }

list_entry ::= value .
list_entry ::= label EQUAL value.

list_list ::= list_entry .
list_list ::= list_list COMMA list_entry .

list_head ::= LBRACKET .                 { check_initial_array_value(data, context, PN_LIST); pn_data_put_list(data); pn_data_enter(data); }
list ::= list_head RBRACKET .            { pn_data_exit(data); }
list ::= list_head list_list RBRACKET .  { pn_data_exit(data); }

// Arrays need at least one element to specify the type
array_list(O) ::= array_value(T) .                        { O = T; }
array_list(O) ::= array_list(T1) COMMA array_value(T2) .  { if (T1==T2) O=T1;
                                                            else {
                                                              pn_error_format(pn_data_error(data), PN_ERR,
                                                                "Array has mixed types");
                                                            }
                                                          }

array_head ::= AT LBRACKET .                { context->initial_array_value=true; }
array ::= array_head array_list RBRACKET .  { pn_data_exit(data); }


symbol(O) ::= COLON string(S) .             { O = S; }
symbol(O) ::= COLON id(S) .                 { O = S; }

%code {
#include "amqp-value.re.c"

#include <stdlib.h>
#include <string.h>

int pn_data_parse(pn_data_t* data, size_t len, const char* s)
{
    char* ws = malloc(len+1);
    memcpy(ws, s, len);
    /* Make sure string had 0 termination */
    ws[len] = 0;
    ByteRange in = { len, ws };

    int tok;
    pn_bytes_t tokValue;

    yyParser parser;
    parse_context context = { .initial_array_value=0 };
    PnParserInit( &parser, &context );
    while ((tok=pni_parser_scan(&in, &tokValue))) {
        PnParser(&parser, tok, tokValue, data);
    }
    PnParser(&parser, tok, tokValue, data);
    PnParserFinalize(&parser);

    free(ws);
    return pn_data_errno(data);
}

int pn_data_parse_string(pn_data_t* data, const char* s)
{
    return pn_data_parse(data, strlen(s), s);
}
}
